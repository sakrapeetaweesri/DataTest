ï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳߥ߲þ߳ݻѺï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳߨþ߳ݴ߫Џњþ߳ݴ߫Ќлњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳþ߳ݳњï߳݌ߩχ߻χ߶ݏߊχï߳݌ߩχЯï߳ݳߐߋ߹þ߳ݳњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳߐߋ߭߰߬ߐ߾þ߳ݓњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳߐߋ߽߭ߙ߲ߺþ߳ݓњþ݈߳њï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳߐߋ߭ߨߖߋ߱þ݈߳њï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߾þ߳ݳњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߼þ߳ݳњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳߺþ߳ݳњþ߳ݳҨҬњï߳݌ߩχ߻χ߶ݏߊχï߳݌ߩχЯï߳ݳߩ߻þ߳ݦњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߯þ߳ݳњþ߳ݳͻњþ߳ݳͻњþ߳ݽњ߹ݳͻњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߯þ߳ݳњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߯߼ߺþ߳ݳњþ߳ݳњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߯ߺ߼þ߳ݳњþ߳ݳњþ߳ݯњþ߳ݯњþ߳ݳƠњþ߳ݳϠњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳþ߳ݼњþ߳ݽњþ߳ݽњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߽߬߬߭þ߳ݳБЍЭњþ߳ݳБЍЭнШЭҨҬњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߻ߵþ߳ݓњþ߳ݳгѝњþ߳ݳгњþ߳ݝЋњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߱þ߳ݓњþ߳ݯǅњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳ߬þ߳ݳЍИњþ߳ݳЯњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳþ߳ݳњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݳþ߳ݳњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߳߮þ߳ݲњþ߳ݲМњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߷þ߳ݷњþ߳݅ҼЗњþ߳ݔҴЗњþ߳ݔҴЛЗњþ߳ݔҴЗњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߸߽߷þ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߲þ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߲߶þ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߱߸þ߳ݒњþ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߱þ߳ݒњþ߳ݲƠњï߳݌ߩχ߻χ߶ݏߊχï߳݌ߩχЯï߳ݲ߱þ߳ݲњþ߳ݲϠњï߳݌ߩχ߻χ߶ݏߊχï߳݌ߩχЯï߳ݲ߱þ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߱þ߳ݲњþ߳ݲ͠њþ߳ݲѲˠњï߳݌ߩχ߻χ߶ݏߊχï߳݌ߩχЯï߳ݲ߱þ߳ݲњï߳݌ߩχ߻χ߶ݏߊχï߳݌ߩχЯï߳ݲþ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߶þ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߶߻ߺþ߳ݲ߶߻ߺњþ߳ݳњ߹в߶߻ߺњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߶þ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߻ߺþ߳ݲњï߳݌ߩχ߻χ߶ݏߊχï߳݌ߩχЯï߳ݲߴ߾þ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߻þ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲߨþ߳ݒњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߫߸߻ߐߋ߯þ߳ݻњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߻ߐߋ߯þ߳ݻњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߻ߐߋ߯þ߳ݻњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲþ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲþ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲߨߨþ߳ݨњþ߳ݝ͠њ߹ݨњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲþ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲþ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲþ߳ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲ߸߽߬ݾþ߳ݻњï߳݌ߩχ߻χ߶ݏ߷ݓߊχ߰ݹЯï߳ݲþ߳ݲҨҬњþ߳ݲњï߳݌ߩχ߻χ߶ݏ߷ݓߊχ߰ݹЯï߳ݾ߶߰вþ߳ݲњï߳݌ߩχ߻χ߶ݐЯï߳ݲ߬þ߳ݲњþ߳ݼњ߹ݲњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲþ߳ݭњþ߳ݭҨҫњþ߳ݭҨҬњï߳݌ߩχ߻χ߶ݏߊχï߳݌ߩχЯï߳ݲþ߳݌Ғњþ߳ݮвњþ߳ݽШвњþ߳ݮњï߳݌ߩχ߻χ߶ݏߊχЯï߳ݲþ߳ݲҨҫњþ߳ݲњï߳݌ߩχ߻χ߶ݏߊχï߳݌ߩχЯï߳ݲߖ߻þ߳ݲ߶߻вњþ߳ݲ߶߻внШвҨҬњþ߳ݲнШвҨҬњþ߳ݲњ߹ݲнШвҨҬњ            height += m_ExpandedRowRects[index].height + kSkinPadding;
                    }

                    height += kGroupPad;
                }
                m_ExpandedRowRects[i] = new Rect(m_RowRects[i].x, m_RowRects[i].y, m_RowRects[i].width, m_RowRects[i].height + height);

                var groupGUI = item as TimelineGroupGUI;
                if (groupGUI != null)
                {
                    var spacing = GetSpacing(item) + 1;
                    groupGUI.expandedRect = m_ExpandedRowRects[i];
                    groupGUI.rowRect = m_RowRects[i];
                    groupGUI.dropRect = new Rect(m_RowRects[i].x, m_RowRects[i].y - spacing, m_RowRects[i].width, m_RowRects[i].height + Mathf.Max(halfHeight, spacing));
                }
            }
        }

        public virtual bool BeginRename(TreeViewItem item, float delay)
        {
            return false;
        }

        public virtual void EndRename() {}

        protected virtual float GetFoldoutIndent(TreeViewItem item)
        {
            // Ignore depth when showing search results
            if (item.depth <= 1 || m_TreeView.isSearching)
                return DirectorStyles.kBaseIndent;

            int depth = item.depth;
            var trackGUI = item as TimelineTrackGUI;

            // first level subtracks are not indented
            if (trackGUI != null && trackGUI.track != null && trackGUI.track.isSubTrack)
                depth--;

            return depth * DirectorStyles.kBaseIndent;
        }

        public virtual float GetContentIndent(TreeViewItem item)
        {
            return GetFoldoutIndent(item);
        }

        public int GetNumRowsOnPageUpDown(TreeViewItem fromItem, bool pageUp, float heightOfTreeView)
        {
            return (int)Mathf.Floor(heightOfTreeView / 30); // return something
        }

        // Should return the row number of the first and last row thats fits in the pixel rect defined by top and height
        public void GetFirstAndLastRowVisible(out int firstRowVisible, out int lastRowVisible)
        {
            int rowCount = m_TreeView.data.rowCount;
            if (rowCount == 0)
            {
                firstRowVisible = lastRowVisible = -1;
                return;
            }

            if (rowCount != m_ExpandedRowRects.Count)
            {
                Debug.LogError("Mismatch in state: rows vs cached rects. Did you remember to hook up: dataSource.onVisibleRowsChanged += gui.CalculateRowRects ?");
                CalculateRowRects();
            }

            float topPixel = m_TreeView.state.scrollPos.y;
            float heightInPixels = m_TreeView.GetTotalRect().height;

            int firstVisible = -1;
            int lastVisible = -1;

            Rect visibleRect = new Rect(0, topPixel, m_ExpandedRowRects[0].width, heightInPixels);
            for (int i = 0; i < m_ExpandedRowRects.Count; ++i)
            {
                bool visible = visibleRect.Overlaps(m_ExpandedRowRects[i]);
                if (visible)
                {
                    if (firstVisible == -1)
                        firstVisible = i;
                    lastVisible = i;
                }

                TimelineTrackBaseGUI gui = m_TreeView.data.GetItem(i) as TimelineTrackBaseGUI;
                if (gui != null)
                {
                    gui.visibleExpanded = visible;
                    gui.visibleRow = visibleRect.Overlaps(m_RowRects[i]);
                }
            }

            if (firstVisible != -1 && lastVisible != -1)
            {
                firstRowVisible = firstVisible;
                lastRowVisible = lastVisible;
            }
            else
            {
                firstRowVisible = 0;
                lastRowVisible = rowCount - 1;
            }
        }

        public Vector2 GetTotalSize()
        {
            if (m_RowRects.Count == 0)
                return new Vector2(0, 0);

            return new Vector2(m_MaxWidthOfRows, m_RowRects[m_RowRects.Count - 1].yMax);
        }

        public virtual float halfDropBetweenHeight
        {
            get { return 8f; }
        }
    }
}
                        TimelineTreeView   UnityEditor.Timeline